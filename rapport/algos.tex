
\section{Conception détaillée}
    \subsection{estVide}
        \begin{algorithme}
            \fonction
                {estVide}
                {pl : Plateau, positionCoup : Position}
                {\booleen}
                {}
                {\retourner{etatPion(obtenirPion(positionCoup,pl))}}
        \end{algorithme}

        \subsection{obtenirCouleurGagnant}
        \begin{algorithme}
            \fonction
                {obtenirCouleurGagnant}
                {pl : Plateau}
                {\booleen , Couleur}
                {nbPionsNoirs, nbPionsBlancs, i, j : \naturel}
                {
                    \affecter{nbPionsNoirs}{0}
                    \affecter{nbPionsBlancs}{0}
                    \pour{i}{1}{8}{}
                    {
                        \pour{j}{1}{8}{}
                        {
                            \sialorssinon{obtenirCouleur(obtenirPion(defPosition(i,j),pl))=Noir}
                            {
                                \affecter{nbPionsNoirs}{nbPionsNoirs+1}   
                            }
                            {
                                \sialors{obtenirCouleur(obtenirPion(defPosition(i,j),pl))=Blanc}
                                {
                                    \affecter{nbPionsBlancs}{nbPionsBlancs+1}
                                }
                            }
                        }
                    }
                    \sialorssinon{nbPionsNoirs $>$ nbPionsBlancs}
                    {
                        \retourner{FAUX , Noir}
                    }
                    {
                        \sialorssinon{nbPionsNoirs $<$ nbPionsBlancs}
                        {
                            \retourner{FAUX , Blanc}
                        }
                        {
                            \retourner{VRAI , Blanc} $on retourne VRAI si egalite et une couleur par defaut$
                        }
                    }
                }
        \end{algorithme}

    \subsection{plusDeCoups}
        \begin{algorithme}
            \fonction
                {plusDeCoups}
                {pl : Plateau, couleurJoueurCourant : Couleur}
                {\booleen}
                {i, j : \naturelNonNul \\ coupOK : \booleen}
                {
                    \affecter{coupOK}{FAUX}
                    \affecter{i}{1}
                    \tantque{non(coupOK) et i $\leqslant$ 8}
                    {
                        \affecter{j}{1}
                        \tantque{non(coupOK) et j $\leqslant$ 8}
                        {
                            \sialors{coupValide(creerPion(couleurJoueurCourant),defPosition(i,j),pl)}
                            {
                                \affecter{coupOK}{VRAI}
                            }
                            \affecter{j}{j+1}
                        }
                        \affecter{i}{i+1}
                    }
                    \retourner{non(coupOK)}
                }
        \end{algorithme}

    \subsection{retournerAuMoinsUnPion}
    \subsubsection{retournerAuMoinsUnPion}
        \begin{algorithme}
            \fonction
                {retournerAuMoinsUnPion}
                {pl : Plateau, leCoup : Coup}
                {\booleen}
                {modifHG, modifH, modifD, modifBD, modifB, modifBG, modifG : \booleen}
                {
                    \affecter{modifHG}{testModifDirection(leCoup,HG)}
                    \affecter{modifH}{testModifDirection(leCoup,H)}
                    \affecter{modifHD}{testModifDirection(leCoup,HD)}
                    \affecter{modifD}{testModifDirection(leCoup,D)}
                    \affecter{modifBD}{testModifDirection(leCoup,BD)}
                    \affecter{modifB}{testModifDirection(leCoup,B)}
                    \affecter{modifBG}{testModifDirection(leCoup,BG)}
                    \affecter{modifG}{testModifDirection(leCoup,G)}
                    \retourner{modifHG ou modifH ou modifHD ou modifD ou modifBD ou modifB ou modifBG ou modfigG}
                }
        \end{algorithme}
        \subsubsection{testModifDirection}
        \begin{algorithme}
            \fonction{testModifDirection}
                {pl : Plateau, leCoup : Coup, direction : \{HG,H,HD,D,BD,B,BG,G\}}
                {\booleen}
                {incrementX, incrementY : \entier \\ positionAtester : Position}
                {
                    \cas{direction}
                    {
                        \casclausegenerale{HG}
                        { 
                            \affecter{incrementX}{-1}
                            \affecter{incrementY}{1}
                        }
                        \casclausegenerale{H}
                        { 
                            \affecter{incrementX}{0}
                            \affecter{incrementY}{1}
                        }
                        \casclausegenerale{HD}
                        { 
                            \affecter{incrementX}{1}
                             \affecter{incrementY}{1}
                        }                        
                        \casclausegenerale{D}
                        { 
                            \affecter{incrementX}{1}
                            \affecter{incrementY}{0}
                        }                        
                        \casclausegenerale{BD}
                        { 
                            \affecter{incrementX}{1}
                            \affecter{incrementY}{-1}
                        }                        
                        \casclausegenerale{B}
                        { 
                            \affecter{incrementX}{0}
                            \affecter{incrementY}{-1}
                        }                        
                        \casclausegenerale{BG}
                        { 
                            \affecter{incrementX}{-1}
                            \affecter{incrementY}{-1}
                        }                        
                        \casclausegenerale{G}
                        { 
                            \affecter{incrementX}{-1}
                            \affecter{incrementY}{0}
                        }
                    }
                    \affecter{positionAtester}{defPosition(obtenirX(obtenirPosCoup(leCoup)+incrementX, obtenirY(obtenirPosCoup(leCoup)+incrementY)))}
                    \sialorssinon{obtenirCouleurCoup(leCoup)=Noir}
                    {
                        \affecter{couleurAdverse}{Blanc}
                    }
                    {
                        \affecter{couleurAdverse}{Noir}
                    }

                    \sialorssinon{obtenirCouleurCoup(leCoup) = obtenirCouleur(obtenirPion(positionAtester,pl))}
                    {
                        \retourner{FAUX}
                    }
                    {
                        \tantque{(obtenirEtatPion(obtenirPion(positionAtester,pl)) $\neq$ 0) et (obtenirCouleur((obtenirPion(positionAtester,pl)) = couleurAdverse)) et (0 $\leqslant$ obtenirX(positionAtester) $\leqslant$ 8) et (0 $\leqslant$ obtenirY(positionAtester) $\leqslant$ 8)}
                        {
                            \affecter{positionAtester}{defPosition(obtenirX(positionAtester) + incrementX, obtenirY(positionAtester) + incrementY)}
                        }
                        \sialorssinon{(obtenirEtatPion(obtenirPion(positionAtester,pl)) $\neq$ 0) et (obtenirCouleur(obtenirPion(positionAtester,pl)) = obtenirCouleurCoup(leCoup))}
                        {
                            \retourner{VRAI}
                        }
                        {
                            \retourner{FAUX}
                        }
                    }
            }
            
        \end{algorithme}

    \subsection{partieTerminee}
        \begin{algorithme}
            \fonction{partieTerminee}
                {pl : Plateau, couleurJoueurCourant : Couleur}
                {\booleen}
                {}
                {\retourner{(plateauPlein(pl) ou plusDeCoups(pl, couleurJoueurCourant))}}
        \end{algorithme}
   
    \subsection{plateauPlein}
        \begin{algorithme}
            \fonction{plateauPlein}
                {pl : Plateau}
                {\booleen}
                {i,j : \naturelNonNul \\ caseVide : \booleen \\ pos : Position}
                {
                    \affecter{caseVide}{FAUX}
                    \affecter{i}{1}
                    \tantque{non(caseVide) et i $\leqslant$ 8}
                    {
                        \affecter{j}{1}
                        \tantque{non(caseVide) et j $\leqslant$ 8}
                        {
                            \affecter{pos}{defPosition(i,j)}
                            \sialors{estVide(pl,pos)}
                            {
                                \affecter{caseVide}{VRAI}
                            }
                            \affecter{j}{j + 1}
                        }
                        \affecter{i}{i + 1}
                    }
                    \retourner{non(caseVide)}
                }
        \end{algorithme}
        
        
     	\subsection{changerCouleur}
     \begin{algorithme}
     	\fonction
     	{changerCouleur}
     	{laCouleur : Couleur}
     	{Couleur}
     	{blanc, noir : Couleur}
     	{
     		\sialorssinon{laCouleur = blanc}
     		{
     			\retourner{noir}
     		}
     		{
     			\retourner{blanc}
     		}
     	}
     \end{algorithme}
     \subsection{definirCouleurNouveauJoueur}
     \begin{algorithme}
     	\fonction
     	{definirCouleurNouveauJoueur}
     	{dernierPionPlace : Pion}
     	{Couleur}
     	{blanc, noir : Couleur}
     	{
     		\retourner{changerCouleur(obtenirCouleurPion(dernierPionPlace))}
     	}
     \end{algorithme}
     
     \subsection{coupValide}
     \begin{algorithme}
     	\fonctionAvecPreconditions
     	{coupValide}
     	{leCoup : Coup, lePlateau : Plateau}
     	{\booleen}
     	{(1 $\leqslant$ obtenirx(obtenirPosition(leCoup)) $\leqslant$ lePlateau.largeur) et (1 $\leqslant$ obteniry(obtenirPosition(leCoup)) $\leqslant$  lePlateau.hauteur)}
     	{}
     	{
     		\sialorssinon{(estVide(obtenirPosition(leCoup), lePlateau)) et (retournerAuMoinsUnPion(lePlateau, leCoup))}
     		{
     			\retourner{VRAI}
     		}
     		{
     			\retourner{FAUX}
     		}
     	}
     \end{algorithme}
     
     \subsection{majPlateau}
     \begin{algorithme}
     	\procedure
     	{majPlateau}
     	{\paramEntreeSortie {lePlateau : Plateau}, \paramEntree {leCoup : Coup, lesDirections : Ensemble$<$Direction$>$}}
     	{element : Direction, onRetourne : \booleen, pos : Position}
     	{
     		\pourchaque{element}{lesDirections}
     		{
     			\affecter{positionsARetourner, onRetourne}{testModifDirection(lePlateau, leCoup, element)}
     			\sialors{onRetourne = VRAI}
     			{
     				
     				\pourchaque{pos}{positionsARetourner}
     				{
     					\instruction{retournerPion(lePlateau, pos)}
     				}
     			}	
     		}
     	}
     	
     \end{algorithme}
     
     
     \subsection{retournerPion}
     \begin{algorithme}
     	\procedure
     	{retournerPion}
     	{\paramEntreeSortie {lePlateau : Plateau},
     		\paramEntree {positionDuPion : Position}}
     	{lePionModifie : Pion}
     	{
     		\affecter {lePionModifie}{obtenirPion(lePlateau, positionDuPion)}
     		\affecter{lePionModifie.couleurPion}{changerCouleur(obtenirCouleurPion(lePionModifie))}
     		\instruction{poserPion(lePionModifie, positionDuPion, lePlateau)}
     	}
     	
     \end{algorithme}
     
     
     
     \subsection{placerCoup}
     \begin{algorithme}
     	\fonctionAvecPreconditions
     	{placerCoup}
     	{partieFinie : booleen, lePlateau : Plateau}
     	{Coup}
     	{non(partieFinie)}
     	{pionAPlacer : Pion, abscisse, ordonnee : \naturel, nouveauCoup : Coup}
     	{
     		
     		\affecter{pionAPlacer.couleur}{definirCouleurNouveauJoueur(pionAPlacer)}
     		\affecter{nouveauCoup.pion}{pionAPlacer}
     		\affecter {nouveauCoup.position}{defPosition(caractereEnEntier(lire(abscisse)), caractereEnEntier(lire(ordonnee)))}
     		
     		\sialors{coupValide(nouveauCoup, pionAPlacer, obtenirPosition(nouveauCoup), lePlateau)}
     		{	
     			\instruction{changerEtat(pionAPlacer)}
     			\retourner{nouveauCoup}
     		}
     		
     	}
     \end{algorithme}
     
    
     \subsection{defPosition}
     \begin{algorithme}
     	\fonctionAvecPreconditions
     	{defPosition}
     	{abscisse, ordonnee : entier} 
     	{Position}
     	{(1 $\leqslant$ abscisse $\leqslant$ lePlateau.largeur) et (1 $\leqslant$ ordonnee $\leqslant$  lePlateau.hauteur)}
     	{laPosition : Position}
     	{
     		\affecter{laPosition.positionx}{abscisse}
     		\affecter{laPosition.positiony}{ordonnee}
     		\retourner{laPosition}
     	}	
     \end{algorithme}
     
     \subsection{obtenirPion}
     \begin{algorithme}
     	\fonctionAvecPreconditions
     	{obtenirPion}
     	{laPosition : Position, lePlateau : Plateau} 
     	{Pion}
     	{(1 $\leqslant$ obtenirx(laPosition) $\leqslant$ lePlateau.largeur) et (1 $\leqslant$ obteniry(laPosition) $\leqslant$  lePlateau.hauteur)}
     	{}
     	{
     		\retourner{lePlateau[obtenirx(laPosition)][obteniry(laPosition)]}
     	}	
     \end{algorithme}




    \subsection{CoupIA}
    \begin{algorithme}
        \fonction{CoupIA}
        {pl : plateau, CouleurReference : Couleur }
        {Coup}
        {estPossible \booleen \\CoupsATester : coups \\ CoupTest,BestCoup : Coup\\ Alpha,Beta :\reel \\ BestScoreCoup, ScoreTemp : \naturel }
        {
            \affecter{CoupsATester}{ObtenirCoupPossible(pl,CouleurReference)}
            \affecter{profondeur}{6}
            \affecter {estPossible}{non(estVide(CoupsATester))}
            \affecter {Alpha}{-infini}
            \affecter {Beta}{+infini}
            \sialors{estPossible}
            {
                \affecter{BestScoreCoup}{0}
                \tantque{non(estVide(CoupsATester))}
                {
                    \affecter{ScoreTemp}{ScoreDUnCoup(pl,CouleurReference,CoupTest,profondeur,Alpha,Beta)}
                    \sialors{BestScoreCoup<ScoreTemp}
                    {
                        \affecter{BestScoreCoup}{ScoreTemp}
                        \affecter{CoupIA}{CoupTest}

                    }
                    \affecter{CoupsATester}{CoupsATester-CoupTest}

                }
            }
        
            \retourner{CoupIA}
        }
    \end{algorithme}


    \subsection{ScoreDUnCoup}
    \begin{algorithme}
        \fonction{ScoreDUnCoup}
        {pl:plateau,CouleurReference:Couleur,coup:Coup,profondeur:\naturel,Alpha:\reel, Beta:\reel}
        {\entier}
        {TestFin : \booleen \\ GrilleTemp: plateau \\ AutreCouleur : Couleur \\ score :\entier}
        {
            \affecter{GrilleTemp}{CopierGrille(pl)}
            \affecter{AutreCouleur}{ChangerCouleur(CouleurReference)}
            \affecter{TestFin}{(ObtenirCoupPossible(pl,CouleurReference)=0) et (ObtenirCoupPossible(pl,AutreCouleur)=0)}
            \instruction{MiseAJourPateau(GrilleTemp,coup)}
            \sialorssinon{(profondeur=0) et (TestFin)}
            {
                \affecter{score}{evalue(GrilleTemp,CouleurReference)}
                \retourner{score}
            }
            {
                \retourner{AlphaBeta(GrilleTemp,CouleurReference,AutreCouleur,Alpha,Beta,profondeur-1)}
            }

        }
    \end{algorithme}






    \subsection{AlphaBeta}
    \begin{algorithme}
        \fonction{AlphaBeta}
        {pl:plateau,CouleurReference:Couleur,CouleurActuel:Couleur,Alpha : \reel,Beta: \reel,profondeur :\naturel}
        {\entier}
        {CoupsPossible : Coups \\ res : \entier \\ score : \entier \\i : \entier}
        {
            \affecter{CoupsPossible}{ObtenirCoupPossible(pl,CouleurActuel)}
            \sialors{non(estVide(CoupsPossible))}
            {
                \affecter{res}{ScoreDUnCoup(pl,CouleurReference,iemeCoup(CoupsPossible,1)profondeur,Alpha,Beta)}
            }
            \pour{i}{2}{nbCoups(CoupsPossible)}{}
            {
                \affecter{score}{ScoreDUnCoup(pl,CouleurReference,iemeCoup(CoupsPossible,i),profondeur,Alpha,Beta)}
                \sialorssinon{CouleurReference<>CouleurActuel}
                {
                    \affecter{res}{max(score,res)}
                    \sialors{res>Alpha}
                    {
                        \affecter{Alpha}{res}
                        \sialors{ALpha>Beta}
                        {
                            \retourner{res}
                        }
                    }
                }
                {
                    \affecter{res}{min(score,res)}
                    \sialors{res<Beta}
                    {
                        \affecter{Beta}{res}
                        \sialors{Beta<ALpha}
                        {
                            \retourner{res}
                        }
                    }
                }
            }
            \retourner{res}
        }
    \end{algorithme}


\subsection{affichagePlateau}
\begin{algorithme}
	\procedure
	{majPlateau}
	{\paramEntree {lePlateau : Plateau}}
	{i, j : \naturel}
	{
		\pour{i}{1}{lePlateau.hauteur}{}{
			\pour{j}{1}{lePlateau.largeur}{}{
				\instruction{ecrire(lePlateau.cases[i][j])}
			}
		}
	}
	
\end{algorithme}

\subsection{faireUnePartie}
\begin{algorithme}
	\fonction
	{faireUnePartie}
	{}
	{Couleur}
	{couleurDuGagnant, joueurCourant : Couleur, joueurOuIA : Booleen, unPlateau : Plateau, coupJoueur1, coupJoueur2, coupIA : Coup, lesDirections : Ensemble$<$Direction$>$}
	{
		\instruction{lire(joueurOuIA)}
		\affecter{joueurCourant}{noir}
		\affecter{unPlateau}{creerPlateau()}
		\sialorssinon{non(JoueurContreIA)}{
			\tantque{non(partieTerminee(unPlateau, joueurCourant))}{
				\affecter{coupJoueur1}{placerCoup(unPlateau, non(partieTerminee(unPlateau)))}
				\instruction{majPlateau(unPlateau, coupJoueur1, lesDirections)}
				\instruction{affichagePlateau(unPlateau)}
				\affecter{coupJoueur2}{placerCoup(unPlateau, non(partieTerminee(unPlateau)))}
				\instruction{majPlateau(unPlateau, coupJoueur2, lesDirections)}
				\instruction{affichagePlateau(unPlateau)}
				}
		}
		{
			\tantque{non(partieTerminee(unPlateau, joueurCourant))}{
				\affecter{coupJoueur}{placerCoup(unPlateau, non(partieTerminee(unPlateau)))}
				\instruction{majPlateau(unPlateau, coupJoueur, lesDirections)}
				\instruction{affichagePlateau(unPlateau)}
				\affecter{coupIA}{moduleIA(unPlateau)}
				\instruction{majPlateau(unPlateau, coupIA, lesDirections)}
				\instruction{affichagePlateau(unPlateau)}
				}
		}
	\instruction{retourner(obtenirCouleurGagnant(unPlateau))}
	
	}
	
	\end{algorithme}

    \subsection{creerPlateau}
	\begin{algorithme}
		\fonction{creerPlateau}
		{}
		{Plateau}
		{blanc, noir : Couleur, unPlateau : Plateau}
		{
			\affecter{unPlateau.hauteur}{8} 
			\affecter{unPlateau.largeur}{8} 
			\instruction{poserPion(creerPion(Blanc), defPosition(4,4), unPlateau)}
			\instruction{poserPion(creerPion(Noir), defPosition(4,5), unPlateau)} 
			\instruction{poserPion(creerPion(Blanc), defPosition(5,5), unPlateau)}
			\instruction{poserPion(creerPion(Noir), defPosition(5,4), unPlateau)}
		}
	\end{algorithme}
