
\section{Conception détaillée}
\subsection{TAD}
\subsubsection{Couleur}
\begin{algorithme}

	\fonction 
	{Blanc}
	{}
	{Couleur}
	{}
	{\retourner{Blanc}}
	\fonction 
	{Noir}
	{}
	{Couleur}
	{}
	{\retourner{Noir}}
	\fonction
	{changerCouleur}
	{couleurActuelle : Couleur}
	{Couleur}
	{}
	{
		\sialorssinon{couleurActuelle = Blanc}{
			\retourner{Noir}
		}
			{
				\retourner{Blanc}
			}
			
	}
	\fonction
	{estBlanc}
	{uneCouleur : Couleur}
	{\booleen}
	{}
	{\sialorssinon{uneCouleur = Noir}
		{\retourner{1}
	}
{\retourner{0}
}
}
	\fonction
	{estNoir}
	{uneCouleur : Couleur}
	{\booleen}
	{}
	{\sialorssinon{uneCouleur = Blanc}
		{\retourner{1}
		}
		{\retourner{0}
	}}

\end{algorithme}

\subsubsection{Coup}
\begin{algorithme}
	\fonction 
	{initCoup}
	{position : Position, pion : Pion}
	{Coup}
	{leCoup : Coup}
	{\affecter{leCoup.positionCoup}{position}
	\affecter{leCoup.Pion}{pion}
	\retourner{leCoup}
	}

	
	\fonction 
	{obtenirPositionCoup}
	{coup : Coup}
	{Position}
	{}
	{\retourner{coup.positionCoup}}
	
	\fonction 
	{obtenirPionCoup}
	{coup : Coup}
	{Pion}
	{}
	{\retourner{coup.Pion}}
	
	\fonction 
	{obtenirCouleurCoup}
	{coup : Coup}
	{Couleur}
	{}
	{\retourner{obtenirCouleurPion(coup.Pion)}}
	
	
	\fonction 
{coupValide}
{leCoup : Coup, lePlateau : Plateau}
{\booleen}
{position : Position}
{
	\affecter{position}{leCoup.positionCoup}
	\retourner{(lePlateau[obtenirX(position)-1][obtenirY(position)-1].etatPion = 0) ET retournerAuMoinsUnPion(lePlateau,leCoup)}
	
}


\fonction 
{obtenirPionCoup}
{coup1, coup2 : Coup}
{\booleen}
{}
{
	\retourner{egal(coup1.Pion,coup2.Pion) ET egal(coup1.positionCoup,coup2.positionCoup)}
}

\end{algorithme}
\subsubsection{Coups}
\begin{algorithme}
\fonction
{initCoups}
{}
{Coups}
{coups : Coups}
{\affecter{coups.nbCoups}{0}
\retourner{coups}}

\fonction
{estVide}
{coups : Coups}
{\booleen}
{}
{\retourner{coups.nbCoups = O} }

\fonctionAvecPreconditions
{iemeCoup}
{coups : Coups, i : \naturel}
{Coup}
{i $>$0 ET i $<= $ nbCoups(coups)}
{}
{\retourner{coups.tabCoups[i-1]} }

\procedureAvecPreconditions
{ajouterCoup}
{{\paramEntreeSortie{coups : Coups, }}{\paramEntree{coup : Coup}}}
{nbCoups(coups) $<$ MAX}{}
{\affecter{tabcoups[nbCoups(coups)]}{coup}
\affecter{nbCoups}{nbCoups+1}}


\fonction
{nbCoups}
{coups : Coups}
{\naturel}
{}
{\retourner{coups.nbCoups}}

\fonctionAvecPreconditions
{estPresent}
{coups : Coups, coup : Coup}
{\booleen}
{non(estVide(coups))}
{i : \naturelNonNul, test = \naturel}
{\pour{i}{1}{coups.nbCoups}{}{
		\sialors{obtenirX(obtenirPositionCoup(coups.tabcoups[i])) = obtenirX(obtenirPositionCoup(coup)) ET obtenirY(obtenirPositionCoup(coups.tabcoups[i])) = obtenirY(obtenirPositionCoup(coup) ET obtenirCouleurCoup(coups.tabcoups[i]) = obtenirCouleurCoup(coup) = 1}{
			\affecter{test}{1}
		}
}
\retourner{test}
}
	
\procedure
{supprimerCoup}
{\paramEntreeSortie{coups : Coups, }{\paramEntree{i : \naturel}}}
{j : \naturel}
{
	\affecter{j}{0}	
	\pour{j}{i}{nbCoups-1}{}{
		\affecter{tabCoups[i]}{tabCoups[i+1]}
	}
\affecter{nbCoups}{nbCoups-1}
}

\fonction
{obtenirCoupsPossible}
{pl : Plateau, couleurReference : Couleur}
{Coups}
{j,i : \naturel, pion : Pion, position : Position, resultat : Coups}
{
		\affecter{j}{0}
		\affecter{i}{0}
		\affecter{resultat}{initCoups()}
		\affecter{pion}{creerPion(CouleurReference)}
	\pour{i}{1}{8}{}{
		\pour{j}{1}{8}{}{
				\affecter{position}{defPosition(i,j)}
					\affecter{coup}{initCoup(position, pion)}
					\sialors{coupValide(coup, pl)}{
						\instruction{ajouterCoup(resultat, coup)}
					
				}
	
}
	
}
\retourner{resultat}
}


\end{algorithme}

\subsubsection{Pion}
\begin{algorithme}

\fonction
{creerPion}
{couleur : Couleur}
{Pion}
{resultat : Pion}
{\affecter{resultat.couleurPion}{couleur}
\affecter{resultata.etatPion}{1}
\retourner{resultat}}

\procedure
{changerEtat}
{\paramEntreeSortie{pion : Pion}}
{resultat : Pion}
{\sialorssinon{pion.etatPion =0}
{\affecter{resultat.etatPion}{1}
}
{\affecter{resultat.etatPion}{0}
}
}
\fonction
{obtenirCouleurPion}
{pion : Pion}
{Couleur}
{}
{\retourner{pion.couleurPion}}

\fonction
{obtenirEtatPion}
{pion : Pion}
{\naturel}
{}
{\retourner{pion.etatPion}}

\fonction
{egal}
{pion1, pion2 : Pion}
{\booleen}
{}
{\retourner{obtenirCouleurPion(pion1) = obtenirCouleurPion(pion2)}}
\end{algorithme}

\subsubsection{Plateau}
\begin{algorithme}

\procedure
{quatrePionsDebut}
{\paramEntreeSortie{plateau : Plateau}}
{}
{\instruction initialiserPlateau(plateau)
	
\instruction	poserPion(creerPion(Blanc()), \instruction defPosition(4,4), plateau)
\instruction	poserPion(creerPion(Noir()), \instruction defPosition(4,5), plateau)
\instruction	poserPion(creerPion(Blanc()), \instruction defPosition(5,5), plateau)
\instruction	poserPion(creerPion(Noir()), \instruction defPosition(5,4), plateau)}

\procedure
{initialiserPlateau}
{\paramEntreeSortie{plateau : Plateau}}
{i, j : \naturelNonNul, position : Position}
{\pour{i}{1}{HAUTEUR}{}{
		\pour{j}{1}{LARGEUR}{}{
			\affecter{position}{defPosition(i,j)}
			\affecter{plateau)[obtenirX(position)-1][obtenirY(position)-1].etatPion}{0}
			}
}}

\fonction
{obtenirPion}
{position : Position, plateau : Plateau}
{Pion}
{}
{\retourner{plateau[obtenirX(position)-1][obtenirY(position)-1]}}

\procedureAvecPreconditions
{poserPion}
{\paramEntreeSortie{{plateau : Plateau, }}{\paramEntree{pion : Pion, position : Position}}}
{estVide(position,plateau)}
{}
{\affecter{plateau)[obtenirX(position)-1][obtenirY(position)-1]}{pion}}

\fonction
{estVide}
{position : Position, plateau : Plateau}
{\booleen}
{}
{\sialorssinon{obtenirEtatPion(obtenirPion(position,plateau)) = 0}{
		\retourner{1}
}
{		\retourner{0}
}
}

\procedure
{copierPlateau}
{\paramEntreeSortie{{plateau : Plateau, }}{\paramEntree{plateauACopier : Plateau}}}
{i, j : \naturelNonNul, position : Position, pion : Pion }
{\pour{i}{1}{HAUTEUR}{}{
		\pour{j}{1}{LARGEUR}{}{
			\affecter{position}{defPosition(i,j)}
			\affecter{plateau)[obtenirX(position)-1][obtenirY(position)-1].etatPion}{0}
			\affecter{pion}{obtenirPion(position, plateauACopier)}
			\sialors{non(estVide(position,plateauACopier))}{
				\instruction{poserPion(pion,position,plateau)}
			}
	}}
}

\end{algorithme}

\subsubsection{Position}
\begin{algorithme}
\fonction
{defPosition}
{x,y : \caractere}
{Position}
{resultat : Position}
{\affecter{resultat.positionx}{x}
\affecter{resultat.positiony}{y}
\retourner{resultat}
}


\fonction
{obtenirX}
{position : Position}
{\caractere}
{}
{\retourner{position.positionx}}

\fonction
{obtenirY}
{position : Position}
{\caractere}
{}
{\retourner{position.positiony}}

\fonction
{egal}
{pos1, pos2 : Position}
{\booleen}
{}
{\retourner{obtenirX(pos1) = obtenirX(pos2) ET (obtenirY(pos1) = obtenirY(pos2)}}
\end{algorithme}
       

        \subsection{obtenirCouleurGagnant}
        \begin{algorithme}
            \fonction
                {obtenirCouleurGagnant}
                {pl : Plateau}
                {\booleen , Couleur}
                {nbPionsNoirs, nbPionsBlancs, i, j : \naturel}
                {
                    \affecter{nbPionsNoirs}{0}
                    \affecter{nbPionsBlancs}{0}
                    \pour{i}{1}{8}{}
                    {
                        \pour{j}{1}{8}{}
                        {
                            \sialorssinon{obtenirCouleur(obtenirPion(defPosition(i,j),pl))=Noir}
                            {
                                \affecter{nbPionsNoirs}{nbPionsNoirs+1}   
                            }
                            {
                                \sialors{obtenirCouleur(obtenirPion(defPosition(i,j),pl))=Blanc}
                                {
                                    \affecter{nbPionsBlancs}{nbPionsBlancs+1}
                                }
                            }
                        }
                    }
                    \sialorssinon{nbPionsNoirs $>$ nbPionsBlancs}
                    {
                        \retourner{FAUX , Noir}
                    }
                    {
                        \sialorssinon{nbPionsNoirs $<$ nbPionsBlancs}
                        {
                            \retourner{FAUX , Blanc}
                        }
                        {
                            \retourner{VRAI , Blanc} $on retourne VRAI si egalite et une couleur par defaut$
                        }
                    }
                }
        \end{algorithme}

    \subsection{plusDeCoups}
        \begin{algorithme}
            \fonction
                {plusDeCoups}
                {pl : Plateau, couleurJoueurCourant : Couleur}
                {\booleen}
                {i, j : \naturelNonNul \\ coupOK : \booleen}
                {
                    \affecter{coupOK}{FAUX}
                    \affecter{i}{1}
                    \tantque{non(coupOK) et i $\leqslant$ 8}
                    {
                        \affecter{j}{1}
                        \tantque{non(coupOK) et j $\leqslant$ 8}
                        {
                            \sialors{coupValide(creerPion(couleurJoueurCourant),defPosition(i,j),pl)}
                            {
                                \affecter{coupOK}{VRAI}
                            }
                            \affecter{j}{j+1}
                        }
                        \affecter{i}{i+1}
                    }
                    \retourner{non(coupOK)}
                }
        \end{algorithme}

    \subsection{retournerAuMoinsUnPion}
    \subsubsection{retournerAuMoinsUnPion}
        \begin{algorithme}
            \fonction
                {retournerAuMoinsUnPion}
                {pl : Plateau, leCoup : Coup}
                {\booleen}
                {modifHG, modifH, modifD, modifBD, modifB, modifBG, modifG : \booleen}
                {
                    \affecter{modifHG}{testModifDirection(leCoup,HG)}
                    \affecter{modifH}{testModifDirection(leCoup,H)}
                    \affecter{modifHD}{testModifDirection(leCoup,HD)}
                    \affecter{modifD}{testModifDirection(leCoup,D)}
                    \affecter{modifBD}{testModifDirection(leCoup,BD)}
                    \affecter{modifB}{testModifDirection(leCoup,B)}
                    \affecter{modifBG}{testModifDirection(leCoup,BG)}
                    \affecter{modifG}{testModifDirection(leCoup,G)}
                    \retourner{modifHG ou modifH ou modifHD ou modifD ou modifBD ou modifB ou modifBG ou modfigG}
                }
        \end{algorithme}
        \subsubsection{testModifDirection}
        \begin{algorithme}
            \fonction{testModifDirection}
                {pl : Plateau, leCoup : Coup, direction : \{HG,H,HD,D,BD,B,BG,G\}}
                {\booleen}
                {incrementX, incrementY : \entier \\ positionAtester : Position}
                {
                    \cas{direction}
                    {
                        \casclausegenerale{HG}
                        { 
                            \affecter{incrementX}{-1}
                            \affecter{incrementY}{1}
                        }
                        \casclausegenerale{H}
                        { 
                            \affecter{incrementX}{0}
                            \affecter{incrementY}{1}
                        }
                        \casclausegenerale{HD}
                        { 
                            \affecter{incrementX}{1}
                             \affecter{incrementY}{1}
                        }                        
                        \casclausegenerale{D}
                        { 
                            \affecter{incrementX}{1}
                            \affecter{incrementY}{0}
                        }                        
                        \casclausegenerale{BD}
                        { 
                            \affecter{incrementX}{1}
                            \affecter{incrementY}{-1}
                        }                        
                        \casclausegenerale{B}
                        { 
                            \affecter{incrementX}{0}
                            \affecter{incrementY}{-1}
                        }                        
                        \casclausegenerale{BG}
                        { 
                            \affecter{incrementX}{-1}
                            \affecter{incrementY}{-1}
                        }                        
                        \casclausegenerale{G}
                        { 
                            \affecter{incrementX}{-1}
                            \affecter{incrementY}{0}
                        }
                    }
                    \affecter{positionAtester}{defPosition(obtenirX(obtenirPosCoup(leCoup)+incrementX, obtenirY(obtenirPosCoup(leCoup)+incrementY)))}
                    \sialorssinon{obtenirCouleurCoup(leCoup)=Noir}
                    {
                        \affecter{couleurAdverse}{Blanc}
                    }
                    {
                        \affecter{couleurAdverse}{Noir}
                    }

                    \sialorssinon{obtenirCouleurCoup(leCoup) = obtenirCouleur(obtenirPion(positionAtester,pl))}
                    {
                        \retourner{FAUX}
                    }
                    {
                        \tantque{(obtenirEtatPion(obtenirPion(positionAtester,pl)) $\neq$ 0) et (obtenirCouleur((obtenirPion(positionAtester,pl)) = couleurAdverse)) et (0 $\leqslant$ obtenirX(positionAtester) $\leqslant$ 8) et (0 $\leqslant$ obtenirY(positionAtester) $\leqslant$ 8)}
                        {
                            \affecter{positionAtester}{defPosition(obtenirX(positionAtester) + incrementX, obtenirY(positionAtester) + incrementY)}
                        }
                        \sialorssinon{(obtenirEtatPion(obtenirPion(positionAtester,pl)) $\neq$ 0) et (obtenirCouleur(obtenirPion(positionAtester,pl)) = obtenirCouleurCoup(leCoup))}
                        {
                            \retourner{VRAI}
                        }
                        {
                            \retourner{FAUX}
                        }
                    }
            }
            
        \end{algorithme}

    \subsection{partieTerminee}
        \begin{algorithme}
            \fonction{partieTerminee}
                {pl : Plateau, couleurJoueurCourant : Couleur}
                {\booleen}
                {}
                {\retourner{(plateauPlein(pl) ou plusDeCoups(pl, couleurJoueurCourant))}}
        \end{algorithme}
   
    \subsection{plateauPlein}
        \begin{algorithme}
            \fonction{plateauPlein}
                {pl : Plateau}
                {\booleen}
                {i,j : \naturelNonNul \\ caseVide : \booleen \\ pos : Position}
                {
                    \affecter{caseVide}{FAUX}
                    \affecter{i}{1}
                    \tantque{non(caseVide) et i $\leqslant$ 8}
                    {
                        \affecter{j}{1}
                        \tantque{non(caseVide) et j $\leqslant$ 8}
                        {
                            \affecter{pos}{defPosition(i,j)}
                            \sialors{estVide(pl,pos)}
                            {
                                \affecter{caseVide}{VRAI}
                            }
                            \affecter{j}{j + 1}
                        }
                        \affecter{i}{i + 1}
                    }
                    \retourner{non(caseVide)}
                }
        \end{algorithme}
        
        
     	\subsection{changerCouleur}
     \begin{algorithme}
     	\fonction
     	{changerCouleur}
     	{laCouleur : Couleur}
     	{Couleur}
     	{blanc, noir : Couleur}
     	{
     		\sialorssinon{laCouleur = blanc}
     		{
     			\retourner{noir}
     		}
     		{
     			\retourner{blanc}
     		}
     	}
     \end{algorithme}
     \subsection{definirCouleurNouveauJoueur}
     \begin{algorithme}
     	\fonction
     	{definirCouleurNouveauJoueur}
     	{dernierPionPlace : Pion}
     	{Couleur}
     	{blanc, noir : Couleur}
     	{
     		\retourner{changerCouleur(obtenirCouleurPion(dernierPionPlace))}
     	}
     \end{algorithme}
     
     \subsection{coupValide}
     \begin{algorithme}
     	\fonctionAvecPreconditions
     	{coupValide}
     	{leCoup : Coup, lePlateau : Plateau}
     	{\booleen}
     	{(1 $\leqslant$ obtenirx(obtenirPosition(leCoup)) $\leqslant$ lePlateau.largeur) et (1 $\leqslant$ obteniry(obtenirPosition(leCoup)) $\leqslant$  lePlateau.hauteur)}
     	{}
     	{
     		\sialorssinon{(estVide(obtenirPosition(leCoup), lePlateau)) et (retournerAuMoinsUnPion(lePlateau, leCoup))}
     		{
     			\retourner{VRAI}
     		}
     		{
     			\retourner{FAUX}
     		}
     	}
     \end{algorithme}
     
     \subsection{majPlateau}
     \begin{algorithme}
     	\procedure
     	{majPlateau}
     	{\paramEntreeSortie {lePlateau : Plateau}, \paramEntree {leCoup : Coup, lesDirections : Ensemble$<$Direction$>$}}
     	{element : Direction, onRetourne : \booleen, pos : Position}
     	{
     		\pourchaque{element}{lesDirections}
     		{
     			\affecter{positionsARetourner, onRetourne}{testModifDirection(lePlateau, leCoup, element)}
     			\sialors{onRetourne = VRAI}
     			{
     				
     				\pourchaque{pos}{positionsARetourner}
     				{
     					\instruction{retournerPion(lePlateau, pos)}
     				}
     			}	
     		}
     	}
     	
     \end{algorithme}
     
     
     \subsection{retournerPion}
     \begin{algorithme}
     	\procedure
     	{retournerPion}
     	{\paramEntreeSortie {lePlateau : Plateau},
     		\paramEntree {positionDuPion : Position}}
     	{lePionModifie : Pion}
     	{
     		\affecter {lePionModifie}{obtenirPion(lePlateau, positionDuPion)}
     		\affecter{lePionModifie.couleurPion}{changerCouleur(obtenirCouleurPion(lePionModifie))}
     		\instruction{poserPion(lePionModifie, positionDuPion, lePlateau)}
     	}
     	
     \end{algorithme}
     
     
     
     \subsection{placerCoup}
     \begin{algorithme}
     	\fonctionAvecPreconditions
     	{placerCoup}
     	{partieFinie : booleen, lePlateau : Plateau}
     	{Coup}
     	{non(partieFinie)}
     	{pionAPlacer : Pion, abscisse, ordonnee : \naturel, nouveauCoup : Coup}
     	{
     		
     		\affecter{pionAPlacer.couleur}{definirCouleurNouveauJoueur(pionAPlacer)}
     		\affecter{nouveauCoup.pion}{pionAPlacer}
     		\affecter {nouveauCoup.position}{defPosition(caractereEnEntier(lire(abscisse)), caractereEnEntier(lire(ordonnee)))}
     		
     		\sialors{coupValide(nouveauCoup, pionAPlacer, obtenirPosition(nouveauCoup), lePlateau)}
     		{	
     			\instruction{changerEtat(pionAPlacer)}
     			\retourner{nouveauCoup}
     		}
     		
     	}
     \end{algorithme}
     
    
     \subsection{defPosition}
     \begin{algorithme}
     	\fonctionAvecPreconditions
     	{defPosition}
     	{abscisse, ordonnee : entier} 
     	{Position}
     	{(1 $\leqslant$ abscisse $\leqslant$ lePlateau.largeur) et (1 $\leqslant$ ordonnee $\leqslant$  lePlateau.hauteur)}
     	{laPosition : Position}
     	{
     		\affecter{laPosition.positionx}{abscisse}
     		\affecter{laPosition.positiony}{ordonnee}
     		\retourner{laPosition}
     	}	
     \end{algorithme}
     
     \subsection{obtenirPion}
     \begin{algorithme}
     	\fonctionAvecPreconditions
     	{obtenirPion}
     	{laPosition : Position, lePlateau : Plateau} 
     	{Pion}
     	{(1 $\leqslant$ obtenirx(laPosition) $\leqslant$ lePlateau.largeur) et (1 $\leqslant$ obteniry(laPosition) $\leqslant$  lePlateau.hauteur)}
     	{}
     	{
     		\retourner{lePlateau[obtenirx(laPosition)][obteniry(laPosition)]}
     	}	
     \end{algorithme}




    \subsection{CoupIA}
    \begin{algorithme}
        \fonction{CoupIA}
        {pl : plateau, CouleurReference : Couleur }
        {Coup}
        {estPossible \booleen \\CoupsATester : coups \\ CoupTest,BestCoup : Coup\\ Alpha,Beta :\reel \\ BestScoreCoup, ScoreTemp : \naturel }
        {
            \affecter{CoupsATester}{ObtenirCoupPossible(pl,CouleurReference)}
            \affecter{profondeur}{6}
            \affecter {estPossible}{non(estVide(CoupsATester))}
            \affecter {Alpha}{-infini}
            \affecter {Beta}{+infini}
            \sialors{estPossible}
            {
                \affecter{BestScoreCoup}{0}
                \tantque{non(estVide(CoupsATester))}
                {
                    \affecter{ScoreTemp}{ScoreDUnCoup(pl,CouleurReference,CoupTest,profondeur,Alpha,Beta)}
                    \sialors{BestScoreCoup<ScoreTemp}
                    {
                        \affecter{BestScoreCoup}{ScoreTemp}
                        \affecter{CoupIA}{CoupTest}

                    }
                    \affecter{CoupsATester}{CoupsATester-CoupTest}

                }
            }
        
            \retourner{CoupIA}
        }
    \end{algorithme}


    \subsection{ScoreDUnCoup}
    \begin{algorithme}
        \fonction{ScoreDUnCoup}
        {pl:plateau,CouleurReference:Couleur,coup:Coup,profondeur:\naturel,Alpha:\reel, Beta:\reel}
        {\entier}
        {TestFin : \booleen \\ GrilleTemp: plateau \\ AutreCouleur : Couleur \\ score :\entier}
        {
            \affecter{GrilleTemp}{CopierGrille(pl)}
            \affecter{AutreCouleur}{ChangerCouleur(CouleurReference)}
            \affecter{TestFin}{(ObtenirCoupPossible(pl,CouleurReference)=0) et (ObtenirCoupPossible(pl,AutreCouleur)=0)}
            \instruction{MiseAJourPateau(GrilleTemp,coup)}
            \sialorssinon{(profondeur=0) et (TestFin)}
            {
                \affecter{score}{evalue(GrilleTemp,CouleurReference)}
                \retourner{score}
            }
            {
                \retourner{AlphaBeta(GrilleTemp,CouleurReference,AutreCouleur,Alpha,Beta,profondeur-1)}
            }

        }
    \end{algorithme}






    \subsection{AlphaBeta}
    \begin{algorithme}
        \fonction{AlphaBeta}
        {pl:plateau,CouleurReference:Couleur,CouleurActuel:Couleur,Alpha : \reel,Beta: \reel,profondeur :\naturel}
        {\entier}
        {CoupsPossible : Coups \\ res : \entier \\ score : \entier \\i : \entier}
        {
            \affecter{CoupsPossible}{ObtenirCoupPossible(pl,CouleurActuel)}
            \sialors{non(estVide(CoupsPossible))}
            {
                \affecter{res}{ScoreDUnCoup(pl,CouleurReference,iemeCoup(CoupsPossible,1)profondeur,Alpha,Beta)}
            }
            \pour{i}{2}{nbCoups(CoupsPossible)}{}
            {
                \affecter{score}{ScoreDUnCoup(pl,CouleurReference,iemeCoup(CoupsPossible,i),profondeur,Alpha,Beta)}
                \sialorssinon{CouleurReference<>CouleurActuel}
                {
                    \affecter{res}{max(score,res)}
                    \sialors{res>Alpha}
                    {
                        \affecter{Alpha}{res}
                        \sialors{ALpha>Beta}
                        {
                            \retourner{res}
                        }
                    }
                }
                {
                    \affecter{res}{min(score,res)}
                    \sialors{res<Beta}
                    {
                        \affecter{Beta}{res}
                        \sialors{Beta<ALpha}
                        {
                            \retourner{res}
                        }
                    }
                }
            }
            \retourner{res}
        }
    \end{algorithme}


\subsection{affichagePlateau}
\begin{algorithme}
	\procedure
	{majPlateau}
	{\paramEntree {lePlateau : Plateau}}
	{i, j : \naturel}
	{
		\pour{i}{1}{lePlateau.hauteur}{}{
			\pour{j}{1}{lePlateau.largeur}{}{
				\instruction{ecrire(lePlateau.cases[i][j])}
			}
		}
	}
	
\end{algorithme}

\subsection{faireUnePartie}
\begin{algorithme}
	\fonction
	{faireUnePartie}
	{}
	{Couleur}
	{couleurDuGagnant, joueurCourant : Couleur, joueurOuIA : Booleen, unPlateau : Plateau, coupJoueur1, coupJoueur2, coupIA : Coup, lesDirections : Ensemble$<$Direction$>$}
	{
		\instruction{lire(joueurOuIA)}
		\affecter{joueurCourant}{noir}
		\affecter{unPlateau}{creerPlateau()}
		\sialorssinon{non(JoueurContreIA)}{
			\tantque{non(partieTerminee(unPlateau, joueurCourant))}{
				\affecter{coupJoueur1}{placerCoup(unPlateau, non(partieTerminee(unPlateau)))}
				\instruction{majPlateau(unPlateau, coupJoueur1, lesDirections)}
				\instruction{affichagePlateau(unPlateau)}
				\affecter{coupJoueur2}{placerCoup(unPlateau, non(partieTerminee(unPlateau)))}
				\instruction{majPlateau(unPlateau, coupJoueur2, lesDirections)}
				\instruction{affichagePlateau(unPlateau)}
				}
		}
		{
			\tantque{non(partieTerminee(unPlateau, joueurCourant))}{
				\affecter{coupJoueur}{placerCoup(unPlateau, non(partieTerminee(unPlateau)))}
				\instruction{majPlateau(unPlateau, coupJoueur, lesDirections)}
				\instruction{affichagePlateau(unPlateau)}
				\affecter{coupIA}{moduleIA(unPlateau)}
				\instruction{majPlateau(unPlateau, coupIA, lesDirections)}
				\instruction{affichagePlateau(unPlateau)}
				}
		}
	\instruction{retourner(obtenirCouleurGagnant(unPlateau))}
	
	}
	
	\end{algorithme}

    \subsection{creerPlateau}
	\begin{algorithme}
		\fonction{creerPlateau}
		{}
		{Plateau}
		{blanc, noir : Couleur, unPlateau : Plateau}
		{
			\affecter{unPlateau.hauteur}{8} 
			\affecter{unPlateau.largeur}{8} 
			\instruction{poserPion(creerPion(Blanc), defPosition(4,4), unPlateau)}
			\instruction{poserPion(creerPion(Noir), defPosition(4,5), unPlateau)} 
			\instruction{poserPion(creerPion(Blanc), defPosition(5,5), unPlateau)}
			\instruction{poserPion(creerPion(Noir), defPosition(5,4), unPlateau)}
		}
	\end{algorithme}
