\section{Conception détaillée}
    \subsection{estVide}
        \begin{algorithme}
            \fonction
                {estVide}
                {pl : Plateau, positionCoup : Position}
                {\booleen}
                {}
                {\retourner{etatPion(obtenirPion(positionCoup,pl))}}
        \end{algorithme}

        \subsection{obtenirCouleurGagnant}
        \begin{algorithme}
            \fonction
                {obtenirCouleurGagnant}
                {pl : Plateau}
                {\booleen , Couleur}
                {nbPionsNoirs, nbPionsBlancs, i, j : \naturel}
                {
                    \affecter{nbPionsNoirs}{0}
                    \affecter{nbPionsBlancs}{0}
                    \pour{i}{1}{8}{}
                    {
                        \pour{j}{1}{8}{}
                        {
                            \sialorssinon{obtenirCouleur(obtenirPion(defPosition(i,j),pl))=Noir}
                            {
                                \affecter{nbPionsNoirs}{nbPionsNoirs+1}   
                            }
                            {
                                \sialors{obtenirCouleur(obtenirPion(defPosition(i,j),pl))=Blanc}
                                {
                                    \affecter{nbPionsBlancs}{nbPionsBlancs+1}
                                }
                            }
                        }
                    }
                    \sialorssinon{nbPionsNoirs $>$ nbPionsBlancs}
                    {
                        \retourner{FAUX , Noir}
                    }
                    {
                        \sialorssinon{nbPionsNoirs $<$ nbPionsBlancs}
                        {
                            \retourner{FAUX , Blanc}
                        }
                        {
                            \retourner{VRAI , Blanc} $on retourne VRAI si egalite et une couleur par defaut$
                        }
                    }
                }
        \end{algorithme}

    \subsection{plusDeCoups}
        \begin{algorithme}
            \fonction
                {plusDeCoups}
                {pl : Plateau, couleurJoueurCourant : Couleur}
                {\booleen}
                {i, j : \naturelNonNul \\ coupOK : \booleen}
                {
                    \affecter{coupOK}{FAUX}
                    \affecter{i}{1}
                    \tantque{non(coupOK) et i $\leqslant$ 8}
                    {
                        \affecter{j}{1}
                        \tantque{non(coupOK) et j $\leqslant$ 8}
                        {
                            \sialors{coupValide(creerPion(couleurJoueurCourant),defPosition(i,j),pl)}
                            {
                                \affecter{coupOK}{VRAI}
                            }
                            \affecter{j}{j+1}
                        }
                        \affecter{i}{i+1}
                    }
                    \retourner{non(coupOK)}
                }
        \end{algorithme}

    \subsection{auMoinsUneModif}
        \begin{algorithme}
            \fonction
                {auMoinsUneModif}
                {pl : Plateau, leCoup : Coup}
                {\booleen}
                {modifHG, modifH, modifD, modifBD, modifB, modifBG, modifG : \booleen}
                {
                    \affecter{modifHG}{testModifDirection(leCoup,HG)}
                    \affecter{modifH}{testModifDirection(leCoup,H)}
                    \affecter{modifHD}{testModifDirection(leCoup,HD)}
                    \affecter{modifD}{testModifDirection(leCoup,D)}
                    \affecter{modifBD}{testModifDirection(leCoup,BD)}
                    \affecter{modifB}{testModifDirection(leCoup,B)}
                    \affecter{modifBG}{testModifDirection(leCoup,BG)}
                    \affecter{modifG}{testModifDirection(leCoup,G)}
                    \retourner{modifHG ou modifH ou modifHD ou modifD ou modifBD ou modifB ou modifBG ou modfigG}
                }
        \end{algorithme}
        \begin{algorithme}
            \fonction
                {testModifDirection}
                {pl : Plateau, leCoup : Coup, direction : \{HG,h,HD,D,BD,B,BG,G\}}
                {\booleen}
                {incrementX, incrementY : \entier \\ positionAtester : Position}
                {
                    % \casou{direction}
                    % {
                    %     HG : 
                    %         \affecter{incrementX}{-1}
                    %         \affecter{incrementY}{1}
                    %     H : 
                    %         \affecter{incrementX}{0}
                    %         \affecter{incrementY}{1}
                    %     HD : 
                    %         \affecter{incrementX}{1}
                    %         \affecter{incrementY}{1}
                    %     D : 
                    %         \affecter{incrementX}{1}
                    %         \affecter{incrementY}{0}
                    %     BD : 
                    %         \affecter{incrementX}{1}
                    %         \affecter{incrementY}{-1}
                    %     B : 
                    %         \affecter{incrementX}{0}
                    %         \affecter{incrementY}{-1}
                    %     BG : 
                    %         \affecter{incrementX}{-1}
                    %         \affecter{incrementY}{-1}
                    %     G : 
                    %         \affecter{incrementX}{-1}
                    %         \affecter{incrementY}{0}
                    % }
                    \affecter{positionAtester}{defPosition(obtenirX(obtenirPosCoup(leCoup)+incrementX, obtenirY(obtenirPosCoup(leCoup)+incrementY)))}
                    \sialorssinon{obtenirCouleurCoup(leCoup)=Noir}
                    {
                        \affecter{couleurAdverse}{Blanc}
                    }
                    {
                        \affecter{couleurAdverse}{Noir}
                    }
                    \tantque{obtenirCouleur((obtenirPion(positionAtester,pl)) = couleurAdverse) et (0 $\leqslant$ obtenirX(positionAtester) $\leqslant$ 8) et (0 $\leqslant$ obtenirY(positionAtester) $\leqslant$ 8)}
                    {
                        \affecter{positionAtester}{defPosition(obtenirX(positionAtester) + incrementX, obtenirY(positionAtester) + incrementY)}
                    }
                    \sialorssinon{obtenirCouleur(obtenirPion(positionAtester,pl)) = obtenirCouleurCoup(leCoup)}
                    {
                        \retourner{VRAI}
                    }
                    {
                        \retourner{FAUX}
                    }
                }
        \end{algorithme}

    \subsection{partieTerminee}
        \begin{algorithme}
            \fonction{partieTerminee}
                {pl : Plateau}
                {\booleen}
                {}
                {\retourner{(plateauPlein ou plusDeCoups)}}
        \end{algorithme}
   
    \subsection{plateauPlein}
        \begin{algorithme}
            \fonction{plateauPlein}
                {pl : Plateau}
                {\booleen}
                {i,j : \naturelNonNul \\ caseVide : \booleen \\ pos : Position}
                {
                    \affecter{caseVide}{FAUX}
                    \affecter{i}{1}
                    \tantque{non(caseVide) et i $\leqslant$ 8}
                    {
                        \affecter{j}{1}
                        \tantque{non(caseVide) et j $\leqslant$ 8}
                        {
                            \affecter{pos}{defPosition(i,j)}
                            \sialors{estVide(pl,pos)}
                            {
                                \affecter{caseVide}{VRAI}
                            }
                            \affecter{j}{j + 1}
                        }
                        \affecter{i}{i + 1}
                    }
                    \retourner{non(caseVide)}
                }
        \end{algorithme}
        
        
     	\subsection{changerCouleur}
     \begin{algorithme}
     	\fonction
     	{changerCouleur}
     	{laCouleur : Couleur}
     	{Couleur}
     	{blanc, noir : Couleur}
     	{
     		\sialorssinon{laCouleur = blanc}
     		{
     			\retourner{noir}
     		}
     		{
     			\retourner{blanc}
     		}
     	}
     \end{algorithme}
     \subsection{definirCouleurNouveauJoueur}
     \begin{algorithme}
     	\fonction
     	{definirCouleurNouveauJoueur}
     	{dernierPionPlace : Pion}
     	{Couleur}
     	{blanc, noir : Couleur}
     	{
     		\retourner{changerCouleur(obtenirCouleurPion(dernierPionPlace))}
     	}
     \end{algorithme}
     
     \subsection{coupValide}
     \begin{algorithme}
     	\fonctionAvecPreconditions
     	{coupValide}
     	{leCoup : Coup, lePlateau : Plateau}
     	{\booleen}
     	{(1 $\leqslant$ obtenirx(obtenirPosition(leCoup)) $\leqslant$ lePlateau.largeur) et (1 $\leqslant$ obteniry(obtenirPosition(leCoup)) $\leqslant$  lePlateau.hauteur)}
     	{}
     	{
     		\sialorssinon{(estVide(obtenirPosition(leCoup), lePlateau)) et (retournerAuMoinsUnPion(lePlateau, leCoup))}
     		{
     			\retourner{VRAI}
     		}
     		{
     			\retourner{FAUX}
     		}
     	}
     \end{algorithme}
     
     \subsection{majPlateau}
     \begin{algorithme}
     	\procedure
     	{majPlateau}
     	{\paramEntreeSortie {lePlateau : Plateau},
     		\paramEntree {leCoup : Coup, lesDirections : Ensemble$<$Direction$>$}}
     	{element : Direction, onRetourne : \booleen, pos : Position}
     	{
     		\pourchaque{element}{lesDirections}
     		{
     			\affecter{positionsARetourner, onRetourne}{testModifDirection(lePlateau, leCoup, element)}
     			\sialors{onRetourne = VRAI}
     			{
     				
     				\pourchaque{pos}{positionsARetourner}
     				{
     					\instruction{retournerPion(lePlateau, pos)}
     				}
     			}	
     		}
     	}
     	
     \end{algorithme}
     
     
     \subsection{retournerPion}
     \begin{algorithme}
     	\procedure
     	{retournerPion}
     	{\paramEntreeSortie {lePlateau : Plateau},
     		\paramEntree {positionDuPion : Position}}
     	{lePionModifie : Pion}
     	{
     		\affecter {lePionModifie}{obtenirPion(lePlateau, positionDuPion)}
     		\affecter{lePionModifie.couleurPion}{changerCouleur(obtenirCouleurPion(lePionModifie))}
     		\instruction{poserPion(lePionModifie, positionDuPion, lePlateau)}
     	}
     	
     \end{algorithme}
     
     
     
     \subsection{placerCoup}
     \begin{algorithme}
     	\fonctionAvecPreconditions
     	{placerCoup}
     	{partieFinie : Booleen, lePlateau : Plateau}
     	{Coup}
     	{non(partieFinie)}
     	{pionAPlacer : Pion, abscisse, ordonnee : \naturel, nouveauCoup : Coup}
     	{
     		
     		\affecter{pionAPlacer.couleur}{definirCouleurNouveauJoueur(pionAPlacer)}
     		\affecter{nouveauCoup.pion}{pionAPlacer}
     		\affecter {nouveauCoup.position}{defPosition(caractereEnEntier(lire(abscisse)), caractereEnEntier(lire(ordonnee)))}
     		
     		\sialors{coupValide(nouveauCoup, pionAPlacer, obtenirPosition(nouveauCoup), lePlateau)}
     		{	
     			\instruction{changerEtat(pionAPlacer)}
     			\retourner{nouveauCoup}
     		}
     		
     	}
     \end{algorithme}
     
    
     \subsection{defPosition}
     \begin{algorithme}
     	\fonctionAvecPreconditions
     	{defPosition}
     	{abscisse, ordonnee : Entier} 
     	{Position}
     	{(1 $\leqslant$ abscisse $\leqslant$ lePlateau.largeur) et (1 $\leqslant$ ordonnee $\leqslant$  lePlateau.hauteur)}
     	{laPosition : Position}
     	{
     		\affecter{laPosition.positionx}{abscisse}
     		\affecter{laPosition.positiony}{ordonnee}
     		\retourner{laPosition}
     	}	
     \end{algorithme}
     
     \subsection{obtenirPion}
     \begin{algorithme}
     	\fonctionAvecPreconditions
     	{obtenirPion}
     	{laPosition : Position, lePlateau : Plateau} 
     	{Pion}
     	{(1 $\leqslant$ obtenirx(laPosition) $\leqslant$ lePlateau.largeur) et (1 $\leqslant$ obteniry(laPosition) $\leqslant$  lePlateau.hauteur)}
     	{}
     	{
     		\retourner{lePlateau[obtenirx(laPosition)][obteniry(laPosition)]}
     	}	
     \end{algorithme}




    \subsection{CoupIA}
    \begin{algorithme}
        \fonction{CoupIA}
        {pl : plateau, CouleurReference : Couleur }
        {Coup}
        {estPossible \booleen \\CoupsATester : coups \\ CoupTest,BestCoup : Coup\\ Alpha,Beta :\reel \\ BestScoreCoup, ScoreTemp : \Naturel }
        {
            \affecter{CoupsATester}{ObtenirCoupPossible(pl,CouleurReference)}
            \affecter{profondeur}{6}
            \affecter {estPossible}{non(estVide(CoupsATester))}
            \affecter {Alpha}{-infini}
            \affecter {Beta}{+infini}
            \sialors{estPossible}
            {
                \affecter{BestScoreCoup}{0}
                \tantque{non(estVide(CoupsATester))}
                {
                    \affecter{ScoreTemp}{ScoreDUnCoup(pl,CouleurReference,CoupTest,profondeur,Alpha,Beta)}
                    \sialors{BestScoreCoup<ScoreTemp}
                    {
                        \affecter{BestScoreCoup}{ScoreTemp}
                        \affecter{CoupIA}{CoupTest}

                    }
                    \affecter{CoupsATester}{CoupsATester-CoupTest}

                }
            }
        
            \retourner{CoupIA}
        }
    \end{algorithme}
    \end{subsection}

    \subsection{ScoreDUnCoup}
    \begin{algorithme}
        \fonction{ScoreDUnCoup}
        {pl:plateau,CouleurReference:Couleur,coup:Coup,profondeur:\Naturel,Alpha:\Reel, Beta:\Real}
        {\Entier}
        {TestFin : \Booleen \\ GrilleTemp: plateau \\ AutreCouleur : Couleur \\ score :\Entier}
        {
            \affecter{GrilleTemp}{CopierGrille(pl)}
            \affecter{AutreCouleur}{ChangerCouleur(CouleurReference)}
            \affecter{TestFin}{(ObtenirCoupPossible(pl,CouleurReference)=0) et (ObtenirCoupPossible(pl,AutreCouleur)=0)}
            \instruction{MiseAJourPateau(GrilleTemp,coup)}
            \sialorssinon{(profondeur=0) et (TestFin)}
            {
                \affecter{score}{evalue(GrilleTemp,CouleurReference)}
                \retourner{score}
            }
            {
                \retourner{AlphaBeta(GrilleTemp,CouleurReference,AutreCouleur,Alpha,Beta,profondeur-1)}
            }

        }
    \end{algorithme}






    \subsection{AlphaBeta}
    \begin{algorithme}
        \fonction{AlphaBeta}
        {pl:plateau,CouleurReference:Couleur,CouleurActuel:Couleur,Alpha : \Reel,Beta: \Reel,profondeur :\Naturel}
        {\Entier}
        {CoupsPossible : Coups \\ res : \Entier \\ score : \Entier \\i : \Entier}
        {
            \affecter{CoupsPossible}{ObtenirCoupPossible(pl,CouleurActuel)}
            \sialors{non(estVide(CoupsPossible))}
            {
                \affecter{res}{ScoreDUnCoup(pl,CouleurReference,iemeCoup(CoupsPossible,1)profondeur,Alpha,Beta)}
            }
            \pour{i}{2}{nbCoups(CoupsPossible)}{}
            {
                \affecter{score}{ScoreDUnCoup(pl,CouleurReference,iemeCoup(CoupsPossible,i),profondeur,Alpha,Beta)}
                \sialorssinon{CouleurReference<>CouleurActuel}
                {
                    \affecter{res}{max(score,res)}
                    \sialors{res>Alpha}
                    {
                        \affecter{Alpha}{res}
                        \sialors{ALpha>Beta}
                        {
                            \retourner{res}
                        }
                    }
                }
                {
                    \affecter{res}{min(score,res)}
                    \sialors{res<Beta}
                    {
                        \affecter{Beta}{res}
                        \sialors{Beta<ALpha}
                        {
                            \retourner{res}
                        }
                    }
                }
            }
            \retourner{res}
        }
    \end{algorithme}
