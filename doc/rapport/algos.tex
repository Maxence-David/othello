\section{Conception détaillée}
    \subsection{estVide}
        \begin{algorithme}
            \fonction
                {estVide}
                {pl : Plateau, positionCoup : Position}
                {\booleen}
                {}
                {\retourner{etatPion(obtenirPion(positionCoup,pl))}}
        \end{algorithme}

        \subsection{obtenirCouleurGagnant}
        \begin{algorithme}
            \fonction
                {obtenirCouleurGagnant}
                {pl : Plateau}
                {\booleen , Couleur}
                {nbPionsNoirs, nbPionsBlancs, i, j : \naturel}
                {
                    \affecter{nbPionsNoirs}{0}
                    \affecter{nbPionsBlancs}{0}
                    \pour{i}{1}{8}{}
                    {
                        \pour{j}{1}{8}{}
                        {
                            \sialorssinon{obtenirCouleur(obtenirPion(defPosition(i,j),pl))=Noir}
                            {
                                \affecter{nbPionsNoirs}{nbPionsNoirs+1}   
                            }
                            {
                                \sialors{obtenirCouleur(obtenirPion(defPosition(i,j),pl))=Blanc}
                                {
                                    \affecter{nbPionsBlancs}{nbPionsBlancs+1}
                                }
                            }
                        }
                    }
                    \sialorssinon{nbPionsNoirs $>$ nbPionsBlancs}
                    {
                        \retourner{FAUX , Noir}
                    }
                    {
                        \sialorssinon{nbPionsNoirs $<$ nbPionsBlancs}
                        {
                            \retourner{FAUX , Blanc}
                        }
                        {
                            \retourner{VRAI , Blanc} $on retourne VRAI si egalite et une couleur par defaut$
                        }
                    }
                }
        \end{algorithme}

    \subsection{plusDeCoups}
        \begin{algorithme}
            \fonction
                {plusDeCoups}
                {pl : Plateau, couleurJoueurCourant : Couleur}
                {\booleen}
                {i, j : \naturelNonNul \\ coupOK : \booleen}
                {
                    \affecter{coupOK}{FAUX}
                    \affecter{i}{1}
                    \tantque{non(coupOK) et i $\leqslant$ 8}
                    {
                        \affecter{j}{1}
                        \tantque{non(coupOK) et j $\leqslant$ 8}
                        {
                            \sialors{coupValide(creerPion(couleurJoueurCourant),defPosition(i,j),pl)}
                            {
                                \affecter{coupOK}{VRAI}
                            }
                            \affecter{j}{j+1}
                        }
                        \affecter{i}{i+1}
                    }
                    \retourner{non(coupOK)}
                }
        \end{algorithme}

    \subsection{auMoinsUneModif}
        \begin{algorithme}
            \fonction
                {auMoinsUneModif}
                {pl : Plateau, leCoup : Coup}
                {\booleen}
                {modifHG, modifH, modifD, modifBD, modifB, modifBG, modifG : \booleen}
                {
                    \affecter{modifHG}{testModifDirection(leCoup,HG)}
                    \affecter{modifH}{testModifDirection(leCoup,H)}
                    \affecter{modifHD}{testModifDirection(leCoup,HD)}
                    \affecter{modifD}{testModifDirection(leCoup,D)}
                    \affecter{modifBD}{testModifDirection(leCoup,BD)}
                    \affecter{modifB}{testModifDirection(leCoup,B)}
                    \affecter{modifBG}{testModifDirection(leCoup,BG)}
                    \affecter{modifG}{testModifDirection(leCoup,G)}
                    \retourner{modifHG ou modifH ou modifHD ou modifD ou modifBD ou modifB ou modifBG ou modfigG}
                }
        \end{algorithme}
        \begin{algorithme}
            \fonction
                {testModifDirection}
                {pl : Plateau, leCoup : Coup, direction : \{HG,h,HD,D,BD,B,BG,G\}}
                {\booleen}
                {incrementX, incrementY : \entier \\ positionAtester : Position}
                {
                    % \casou{direction}
                    % {
                    %     HG : 
                    %         \affecter{incrementX}{-1}
                    %         \affecter{incrementY}{1}
                    %     H : 
                    %         \affecter{incrementX}{0}
                    %         \affecter{incrementY}{1}
                    %     HD : 
                    %         \affecter{incrementX}{1}
                    %         \affecter{incrementY}{1}
                    %     D : 
                    %         \affecter{incrementX}{1}
                    %         \affecter{incrementY}{0}
                    %     BD : 
                    %         \affecter{incrementX}{1}
                    %         \affecter{incrementY}{-1}
                    %     B : 
                    %         \affecter{incrementX}{0}
                    %         \affecter{incrementY}{-1}
                    %     BG : 
                    %         \affecter{incrementX}{-1}
                    %         \affecter{incrementY}{-1}
                    %     G : 
                    %         \affecter{incrementX}{-1}
                    %         \affecter{incrementY}{0}
                    % }
                    \affecter{positionAtester}{defPosition(obtenirX(obtenirPosCoup(leCoup)+incrementX, obtenirY(obtenirPosCoup(leCoup)+incrementY)))}
                    \sialorssinon{obtenirCouleurCoup(leCoup)=Noir}
                    {
                        \affecter{couleurAdverse}{Blanc}
                    }
                    {
                        \affecter{couleurAdverse}{Noir}
                    }
                    \tantque{obtenirCouleur((obtenirPion(positionAtester,pl)) = couleurAdverse) et (0 $\leqslant$ obtenirX(positionAtester) $\leqslant$ 8) et (0 $\leqslant$ obtenirY(positionAtester) $\leqslant$ 8)}
                    {
                        \affecter{positionAtester}{defPosition(obtenirX(positionAtester) + incrementX, obtenirY(positionAtester) + incrementY)}
                    }
                    \sialorssinon{obtenirCouleur(obtenirPion(positionAtester,pl)) = obtenirCouleurCoup(leCoup)}
                    {
                        \retourner{VRAI}
                    }
                    {
                        \retourner{FAUX}
                    }
                }
        \end{algorithme}

    \subsection{partieTerminee}
        \begin{algorithme}
            \fonction{partieTerminee}
                {pl : Plateau}
                {\booleen}
                {}
                {\retourner{(plateauPlein ou plusDeCoups)}}
        \end{algorithme}
   
    \subsection{plateauPlein}
        \begin{algorithme}
            \fonction{plateauPlein}
                {pl : Plateau}
                {\booleen}
                {i,j : \naturelNonNul \\ caseVide : \booleen \\ pos : Position}
                {
                    \affecter{caseVide}{FAUX}
                    \affecter{i}{1}
                    \tantque{non(caseVide) et i $\leqslant$ 8}
                    {
                        \affecter{j}{1}
                        \tantque{non(caseVide) et j $\leqslant$ 8}
                        {
                            \affecter{pos}{defPosition(i,j)}
                            \sialors{estVide(pl,pos)}
                            {
                                \affecter{caseVide}{VRAI}
                            }
                            \affecter{j}{j + 1}
                        }
                        \affecter{i}{i + 1}
                    }
                    \retourner{non(caseVide)}
                }
        \end{algorithme}
        
        
        	\subsection{changerCouleur}
        \begin{algorithme}
        	\fonction
        	{changerCouleur}
        	{laCouleur : Couleur}
        	{Couleur}
        	{blanc, noir : Couleur}
        	{
        		\sialorssinon{laCouleur = blanc}
        		{
        			\retourner{noir}
        		}
        		{
        			\retourner{blanc}
        		}
        	}
        \end{algorithme}
        \subsection{definirCouleurNouveauJoueur}
        \begin{algorithme}
        	\fonction
        	{definirCouleurNouveauJoueur}
        	{dernierPionPlace : Pion}
        	{Couleur}
        	{blanc, noir : Couleur}
        	{
        		\retourner{changerCouleur(obtenirCouleurPion(dernierPionPlace))}
        	}
        \end{algorithme}
        
        \subsection{coupValide}
        \begin{algorithme}
        	\fonctionAvecPreconditions
        	{coupValide}
        	{leCoup : Coup, lePlateau : Plateau}
        	{\booleen}
        	{(1 $\leqslant$ obtenirx(obtenirPosition(leCoup)) $\leqslant$ 8) et (1 $\leqslant$ obteniry(obtenirPosition(leCoup)) $\leqslant$  8)}
        	{}
        	{
        		\sialorssinon{(estVide(obtenirPosition(leCoup), lePlateau)) et (retournerAuMoinsUnPion(lePlateau, leCoup))}
        		{
        			\retourner{VRAI}
        		}
        		{
        			\retourner{FAUX}
        		}
        	}
        \end{algorithme}
        
        \subsection{majPlateau}
        \begin{algorithme}
        	\procedure
        	{majPlateau}
        	{\paramEntreeSortie {lePlateau : Plateau},
        		\paramEntree {leCoup : Coup, lesDirections : Ensemble<Direction>}}
        	{element : Direction, onRetourne : \booleen, pos : Position}
        	{
        		\pourchaque{element}{lesDirections}
        		{
        			\affecter{positionsARetourner, onRetourne}{testModifDirection(lePlateau, leCoup, element)}
        			\sialors{onRetourne = VRAI}
        			{
        				
        				\pourchaque{pos}{positionsARetourner}
        				{
        					\instruction{retournerPion(lePlateau, pos)}
        				}
        			}	
        		}
        	}
        	
        \end{algorithme}
        
        
        \subsection{retournerPion}
        \begin{algorithme}
        	\procedure
        	{retournerPion}
        	{\paramEntreeSortie {lePlateau : Plateau},
        		\paramEntree {positionDuPion : Position}}
        	{lePionModifie : Pion}
        	{
        		\affecter {lePionModifie}{obtenirPion(lePlateau, positionDuPion)}
        		\affecter{lePionModifie.couleurPion}{changerCouleur(obtenirCouleurPion(lePionModifie))}
        		\instruction{poserPion(lePionModifie, positionDuPion, lePlateau)}
        	}
        	
        \end{algorithme}
    
        


            